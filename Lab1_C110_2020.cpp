/*************************************************************
	Практическое занятие №1. Встроенные многомерные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <ctime>

#define	  stop __asm nop

int main()
{

	///////////////////////////////////////////////////////////////
	//			Встроенные  многомерные массивы                               //
	///////////////////////////////////////////////////////////////

		//Задание 1.
		//Объявите трехмерный N*M*K массив и сформируйте указанные
		//значения элементов следующим образом:
		//а) проинициализируйте массив при объявлении

	{
		const int N = 3, M = 3, K = 3;

		int Ar[][M][K] = { {{1, 1, 1},
						   {1, 1, 1},
						   {1, 1, 1}},
										{{2, 2, 2},
										{2, 2, 2},
										{2, 2, 2}},
													{{3, 3, 3},
													{3, 3, 3},
													{3, 3, 3} } };
		stop
	}


	////б) объявите неинициализированный массив и присвойте значения элементам
	////	с помощью кода
	////					 |--------|		
	////				   / |3  3  3 |		
	////    			 |---------|3 |
	//	//		   / | 2  2  2 |3 |
	////			  |---------|2 |__|
	////			  | 1  1  1 |2 | /
	////			  | 1  1  1 |__| 
	////			  | 1  1  1 | /
	////			  |_________|
	////Рекомендация: В качестве размерностей массива лучше указать N, M, K,
	////а не  задавать их жестко.  
	////Средствами отладчика проверьте правильность Вашего решения. 
	////Или выведите содержимое массива на печать.
	//// Удобно выводить построчно каждый слой  массива и 
	////после каждого слоя пропускать строку для того, чтобы отделить один слой от другого

	{
		const int N = 3, M = 3, K = 3;

		int Ar[N][M][K];

		for (int iii = 0; iii < N; iii++)
			for (int jjj = 0; jjj < M; jjj++)
				for (int kkk = 0; kkk < K; kkk++)
				{

					Ar[iii][jjj][kkk] = iii + 1;

				}

		stop



	//		//в) найдите сумму элементов массива. Подумайте, как это сделать эффективно.
			int sum = 0;
		int* ptr = &Ar[0][0][0];

		for (int i = 0; i < M * N * K; i++)
		{
			sum += *ptr++;
		}

		stop
	}
	////г) проинициализируйте массив при определении:
	////				     |--------|		
	////			       / |3  0  0 |		
	////      		 |---------|0 |
	////    		   / | 2  0  0 |0 |
	////			  |---------|0 |__|
	////			  | 1  0  0 |0 | /
	////			  | 0  0  0 |__| 
	////			  | 0  0  0 | /
	////			  |_________|

	{
		const int N = 3, M = 3, K = 3;

		int Ar[N][M][K] = { {{1}}, {{2}}, {{3}} };
		stop
	}

	////д) Инициализация массивов строковыми литералами:
	////Объявите и проинициализируйте строковыми литералами два массива:
	////двухмерный массив и массив указателей. Поясните разницу в использовании
	////элементов таких массивов.

	{
		char Ar1[][6] = { "One","Two","Three" }; //в памяти гарантированно подряд хранятся

		const char* Ar2[] = { "One", "Two", "Three" };
		Ar1[1][1] = 'W';
		//*(Ar2[1]) = 'W';
		//Ar2[1][1] = 'W';
		stop
	}

	///////////////////////////////////////////////////////////////////////
	////Задание 2.
	////С помощью данной заготовки напишите программу,которая:
	////вводит строки с клавиатуры с помощью cin>>...
	////в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 10*80 элементов типа char;
	////признаком конца ввода является символ * (то есть строка - "*") или
	////заполнение всего массива (больше свободных строк нет);

	////То есть:
	//	//a) можно заполнять весь массив полностью (не забудьте подсказать, сколько элементов в массиве)
	//	//б) можно заполнять массив частично, до тех пор, пока пользователь не ввел строку "*".
	//	//Например:вводим строки (строки с пробелами не задаются, т.к. пробелы являются разделителями):
	//	//"Hello"
	//	//"Ok"
	//	//"*"



	////сортировка строк в алфавитном порядке. 
	////Пояснение: крайне не рекомендуется для сортировки сложных объектов физически
	////перемещать их в памяти ( в нашем случае перемещать (копировать) строки)
	////Намного эффективнее завести массив указателей на соответствующие строки 
	////и перемещать только указатели на начало строк (массивов символов).
	////Вопрос: При таком способе что будет  отсортировано?

	////Подсказка: для лексикографического сравнения строк пользуйтесь
	////функцией стандартной библиотеки strcmp(...), заголовочный файл <string.h>.
	////int strcmp(char const* _Str1, char const* _Str2);
	{

	//	//Определите необходимые значения как константы
	//	//STOP_STRING  -  "*"	//признак "прекратить ввод"
		const char* STOP_STRING = "*";
	//	//M  -  80	//максимальный размер одной строки
		const int M = 80;
	//	//N  -  10	//максимальное количество строк в массиве
		const int N = 10;



	//	//Объявите двухмерный массив с именем cBuffer типа char и
	//	// размерностью N*M

		char cBuffer[N][M] = { 0 };


	//	//Объявите массив (с именем cPointers) указателей на строки
	//	//размерностью N

		char* cPointer[N] = { 0 };

	//	//Цикл ввода строк:
	//	//а) выведите приглашение для ввода
		std::cout << "Enter strings (10x80) or '*' to finish\n";
	//	//б) пока не введена строка STOP_STRING или не заполнен весь массив

		int iii = 0;

		while (iii < N)
		{

			std::cin >> cBuffer[iii];		//ввод строки в массив cBuffer

			if (!strcmp(cBuffer[iii], STOP_STRING))	//если введена строка - признак окончания, то выйти из цикла
				break;
			cPointer[iii] = &cBuffer[iii][0];
			iii++;
		}




	//	//Присвойте элементу массива cPointers с индексом nIndex
	//	//указатель на строку с номером nIndex в массиве cBuffer



	//	//Выдать диагностику о том, что прием строк завершен.

		std::cout << "Array fill complete";

	//	//Теперь сортируем строки:

	////Цикл сортировки строк по методу "всплывающего пузырька" в
	////порядке возрастания кода первого символа


		for (int j = 0; j < N; j++)
		{
			bool flag = 0;

			for (int i = 0; i < N - j - 1; i++)
			{



				if ((cPointer[i]) && (cPointer[i + 1]) && (*(cPointer[i]) > * (cPointer[i + 1])))
				{
					char* tmp = cPointer[i];
					cPointer[i] = cPointer[i + 1];
					cPointer[i + 1] = tmp;
					flag = 1;
				}

			}
			if (!flag)
			{
				break;
			}
		}

		stop;

		std::cout << "\nString array after sort\n";

		for (int i = 0; i < N; i++)
		{
			if (cPointer[i])
			{
				std::cout << cPointer[i] << std::endl;
			}
		}
	}
	stop
	//////////////////////////////////////////////////////////////////////////////

	//Задание 3*. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив
	//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
	//кода, который меняет местами значения элементов четных
	//и нечетных слоев:
	//	было:			     |--------|
	//  				   / |4  4  4 |
	//				     |--------| 4 |
	//			       / |3  3  3 | 4 |
	//    			 |---------|3 |   |
	//			   / | 2  2  2 |3 | /
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__|
	//			  | 1  1  1 | /
	//			  |_________|

	//	стало:			     |--------|
	//  				   / |3  3  3 |
	//				     |--------| 3 |
	//			       / |4  4  4 | 3 |
	//    			 |---------|4 |   |
	//			   / | 1  1  1 |4 | /
	//			  |---------|1 |__|
	//			  | 2  2  2 |1 | /
	//			  | 2  2  2 |__|
	//			  | 2  2  2 | /
	//			  |_________|
	{
		const int N = 4, M = 3, K = 3;

		int Ar[N][M][K];

		for (int iii = 0; iii < N; iii++)
			for (int jjj = 0; jjj < M; jjj++)
				for (int kkk = 0; kkk < K; kkk++)
				{

					Ar[iii][jjj][kkk] = iii + 1;
				}



		for (int i = 0; i < N; i++)
		{
			
			int (*ptr1)[M] = Ar[i];
			int(*ptr2)[M] = Ar[i+1];
			i++;
			for (int j = 0; j < M; j++)
				for (int k = 0; k < K; k++)
					std::swap(ptr1[j][k], ptr2[j][k]);
						//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
						//... = dArray[i];
						//... = dArray[i + 1];
						//Подсказки: 
						//1) Слева от знака равенства надо определить два  сложных указателя. 
						//Так как справа находятся "имена" слоев, т.е. двумерных массивов, то
						// остается вспомнить какой указатель является эквивалентным имени двумерного массива.
						//2)дальше, воспользовавшись этими указателями, переставляем местами элементы i-того и i+1-ого слоев


		}

			
	
			stop
			

		
	}

///////////////////////////////////////////////////////////////////////////

//Задание 4
//а) Объявите двухмерный ВСТРОЕННЫЙ массив элементов типа char.
	{
		const int N = 5, M = 5;
		char cAr[N][M];
		//Сформируйте значения элементов массива с помощью генератора случайных
		//чисел таким образом, чтобы в массиве были только символы '_' и '*'

			//Подсказка 1: для генерации случайных чисел используйте функцию
			//стандартной библиотеки - rand() (<cstdlib>)
			//Можно с помощью генератора случайных чисел  и оператора % получать значения 0 и 1,
			// а в массив помещать соответственно '_' и '*'.


			//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
			//чисел являются «псевдослучайными», то есть при двух последовательных запусках
			//приложения Вы получаете две одинаковые последовательности значений.
			//Для того чтобы генерируемые "случайные" значения были разными при каждом
			//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
			//и time() (<ctime>).
			//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
			//Функция time() задает эту точку отсчета, считывая текущее время
			//srand( time( 0 ) );

			//Замечание: в программе запускать функцию srand()  достаточно один раз 

		srand(time(0));

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				if ((rand()%2))
				{
					cAr[i][j] = '*';
				}
				else
				{
					cAr[i][j] = '_';
				}
			}

		}

		std::cout << std::endl << "4.a. before:" << std::endl;

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << cAr[i][j];
			}
			std::cout << std::endl;

		}
		std::cout << std::endl;

		
			//В каждой строке "сдвиньте звездочки" в начало строки, например:
			//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
			//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
			//и распечатайте массив по строкам - "постройте распределение"

		for (int i = 0; i < N; i++)
		{

			char* begin = &cAr[i][0];
			char* end = &cAr[i][M - 1];

			for (int j = 0; j < M; j++)
			{
				while(begin<end)
				{

					if (*begin == '*')
						begin++;

					else {
						if (*end == '*')
						{
							std::swap(*begin, *end);
							end--;
						}
						else end--;
					}
				}

			}

		}

		std::cout << std::endl << "4.a. after:" << std::endl;

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << cAr[i][j];
			}
			std::cout << std::endl;

		}
		std::cout << std::endl;
		stop

	}
// б) Модифицируйте предыдущее задание следующим способом:
//После заполнения массива с помощью генератора случайных чисел
//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
//"распределение"

	{
		const int N = 5, M = 5;
		char cAr[N][M];
	

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				if ((rand() % 2))
				{
					cAr[i][j] = '*';
				}
				else
				{
					cAr[i][j] = '_';
				}
			}

		}

		std::cout << std::endl << "4.b. before:" << std::endl;

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << cAr[i][j];
			}
			std::cout << std::endl;

		}
		std::cout << std::endl;
		

		for (int i = 0; i < M; i++)
		{
			char* begin = &cAr[0][i];
			char* end = &cAr[N][i];

			for (int j = 0; j < N; j++)
			{
				while (begin < end)
				{

					if (*begin == '_')
						begin+=M;

					else {
						if (*end == '_')
						{
							std::swap(*begin, *end);
							end-=M;
						}
						else end-=M;
					}
				}
			}

		}

		std::cout << std::endl << "4.b. after:" << std::endl ;
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << cAr[i][j];
			}
			std::cout << std::endl;

		}
		std::cout << std::endl;
		stop

	}

///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
//Задание 5.
	////Задание 5а.Создайте ДИНАМИЧЕСКИЙ двухмерный массив с размерностями,
	//вычисляемыми в процессе выполнения программы - N*M.
	{
		int N = 15;
		int M = 6;

		int** Ar = new int* [N];

		for (int i = 0; i < N; i++)
		{
			Ar[i] = new int[M];
		}


		//Задайте значения элементов помощью генератора случайных чисел.

		for (int i = 0; i < N; i++)
			for (int j = 0; j < M; j++)
			{
				Ar[i][j] = rand() % 11;
			}


		std::cout << '\n' << "5a. array before sort:\n";

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << Ar[i][j] <<' ';
			}
			std::cout << '\n';
		}


		//Задание 5б. В сформированном массиве отсортируйте каждую строку по
		//убыванию значений. Используйте сортировку "выбором"

		for (int str=0; str<N; str++)
		{
			for (int index_i = 0; index_i < M - 1; index_i++)
			{
				int min_index = index_i;
				for (int index_j = index_i + 1; index_j < M; index_j++)
				{
					if (Ar[str][index_j] < Ar[str][min_index])
					{
						min_index = index_j;
					}
				}
					if (min_index != index_i)
				{
					std::swap(Ar[str][index_i], Ar[str][min_index]);
				}
			}
		}
			std::cout << '\n' << "5b. array after sort:\n";

			for (int i = 0; i < N; i++)
			{
				for (int j = 0; j < M; j++)
				{
					std::cout << Ar[i][j] << ' ';
				}
				std::cout << '\n';
			}

			//Задание 5в. Объявите одномерный массив размерностью N.
			//Сформируйте значение i-ого элемента одномерного массива  
			//равным среднему значению элементов i-ой строки
			//двухмерного массива
			int* Average = new int[N];

			for (int i = 0; i < N; i++)
			{
				int sum_j = 0;
				for (int j = 0; j < M; j++)
				{
					sum_j += Ar[i][j];
				}
				Average[i] = sum_j / M;
			}

			std::cout << "\n5c. Average array:\n";

			for (int i = 0; i < N; i++)
			{
				std::cout << Average[i]<<'\n';
			}
			//Подсказка - не забудьте освободить память!
		
			delete[] Average;

			for (int i = 0; i < N; i++)
			{
				delete[] Ar[i];
			}

			delete[] Ar;
			
}
/////////////////////////////////////////////////////////////////////////////
//Задание 6. 
	//Реализуйте задание №2, используя не встроенные, а ДИНАМИЧЕСКИЕ массивы (массив?).
	// Важно! 
	//Так как строки могут быть разной длины, /эффективным решением было бы 
	//отводить под каждую строку ровно столько байтов, сколько требуется для ее хранения.
	//
	//Для того, чтобы определить длину введенной строки можно воспользоваться 
	//функцией strlen 
	//size_t strlen(char const* _Str);
std::cout << "\n6\n";
	const char* STOP_STRING = "*";
	//При этом значение количества строк сформируйте с помощью потока ввода
	int nStringNumber;
	std::cout << "Enter number of string\n";
	std::cin >> nStringNumber;

	char** strAr = new char* [nStringNumber];

	

	//Цикл ввода строк:
	for (int i = 0; i < nStringNumber; i++)
	{

		// Для ввода строки нужно использовать буфер "достаточного" размера. 
		// В качестве такого буфера обычно используется встроенный массив.

		char Buffer[80] = { '\0' };
		std::cout << "Enter string #"<<i+1<<" or '*' to finish"<<'\n';
		std::cin >> Buffer;
		int len = strlen(Buffer);
		
		if (!strcmp(Buffer, STOP_STRING))		// при введении "*" прекращаем ввод
		{
			nStringNumber = i;
		}

		
		strAr[i] = new char[len+1];

		// Для того, чтобы введенную строку  скопировать из буфера в массив  строк,
		// можно воспользоваться функцией strcpy
		//char* strcpy_s(	char* _Dest,  char const* _Source);
		//  или
		//errno_t strcpy_s(char* _Dest, size_t  _SizeInBytes, char const* _Source); 
		//где _SizeInBytes - размер "приемного" буфера.

		strcpy(strAr[i], Buffer);

		//Замечание: 
		//скорее всего, при компиляции Вы получите следующую ошибку:
		//Severity	Code	Description	Project	File	Line	Suppression State
		//	Error	C4996	'strcpy': This function or variable may be unsafe.
		//Consider using strcpy_s instead.To disable deprecation, use _CRT_SECURE_NO_WARNINGS.

		//Это происходит потому, что функция strcpy считается небезопасной.

		//Для того, чтобы пользоваться функцией strcpy, а не strcpy_s, можно
		//  - либо объявить макрос #define _CRT_SECURE_NO_WARNINGS   (обязательно ДО всех #include !!!!!)
		//- либо установить режим без доп. проверки на безопасность Properties->C/C++ ->General->SDL checs -> No
	}

	
	stop
		//Цикл сортировки строк по методу "всплывающего пузырька" в
		//порядке возрастания кода первого символа
														//	ВАРИАНТ 1. сортируются сами строки
			for (int j = 0; j < nStringNumber; j++)
		{
			bool flag = 0;

			for (int i = 0; i < nStringNumber - j - 1; i++)
			{

				if (*strAr[i]>*strAr[i+1])
				{
					std::swap(strAr[i], strAr[i + 1]);
					flag = 1;
				}

			}
			if (!flag)
			{
				break;
			}
		}
		

	//	char** cPointer = new char*[nStringNumber]; //					ВАРИАНТ 2 сортируется вспомогательный массив указателей

	//for (int i = 0; i < nStringNumber; i++)
	//{
	//	cPointer[i] = strAr[i];
	//}

	//for (int j = 0; j < nStringNumber; j++)
	//{
	//	bool flag = 0;

	//	for (int i = 0; i < nStringNumber - j - 1; i++)
	//	{

	//		if ((cPointer[i]) && (cPointer[i + 1]) && (*(cPointer[i]) > * (cPointer[i + 1])))
	//		{
	//			char* tmp = cPointer[i];
	//			cPointer[i] = cPointer[i + 1];
	//			cPointer[i + 1] = tmp;
	//			flag = 1;
	//		}

	//	}
	//	if (!flag)
	//	{
	//		break;
	//	}
	//}

	stop

		std::cout << "\nStrings after sort:\n";
												//		распечатка для 1 варианта
	for (int i = 0; i < nStringNumber; i++)
		std::cout << strAr[i]<<'\n';
	std::cout << std::endl;
	

	//for (int i = 0; i < nStringNumber; i++)			//распечатка для 2-го варианта
	//{
	//	std::cout << cPointer[i]<<'\n';
	//}
	//	//Освобождение занятой памяти:
	//
	//delete[] cPointer;

	for(int i=0; i<nStringNumber; i++)
		delete[] strAr[i];

	delete[] strAr;

	return 0; 
}